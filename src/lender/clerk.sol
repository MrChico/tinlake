pragma solidity >=0.5.15. <0.6.0;

contract Clerk {
    // --- Auth ---
    mapping (address => uint) public wards;
    function rely(address usr) external auth { require(live, "mgr/not-live"); wards[usr] = 1; }
    function deny(address usr) external auth { require(live, "mgr/not-live"); wards[usr] = 0; }
    modifier auth {
        require(wards[msg.sender] == 1, "mgr/not-authorized");
        _;
    }

    constructor(address mgr_, address dai_, address assessor) {
        dai = dai_;
        mgr = mgr_;
        assessor = assessor_;
        wards[msg.sender] = 1;
    }

    uint public expectedRevenue;
    address public mgr;
    address public dai;

    // --- Math ---

    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x);
    }
    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x);
    }
    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function join(uint d) public auth {
        mgr.join(d);
        uint vb = assessor.seniorVirtualBalance();
        // add a virtual balance to calculation of dropPrice so that price remains constant.
        assessor.setVirtualBalance(add(vb, sub(mul(calcSeniorAssetValue(assessor.seniorDebt(), assessor.seniorBalance(), vb), add(senior.totalSupply(), d)) / senior.totalSupply(), add(assessor.seniorDebt(), assessor.seniorBalance()))));
    }

    function draw(uint d) public auth {
        require(reserves == 0, "Use money in reserves first");
        drip();
        mgr.draw(d);
        uint vb = assessor.seniorVirtualBalance();
        // decrease virtualbalance by dai (price remains constant)
        assessor.setVirtualBalance(sub(vb, dai));
        expectedRevenue = add(expectedRevenue, dai);

        // TODO: how to make it so this dai is added to the senior balance?
        dai.transfer(senior, dai);
    }

    function wipe(uint d) public auth {
        require(mgr.tab() > 0, "loan already repaid");
        drip();
        expectedRevenue = sub(expectedRevenue, d);
        mgr.wipe(d);
    }

    // give the revenue generated by the loans financed by the clerk
    // to the juniors
    function balance(uint wad) public {
        require(mgr.tab() == 0, "Dai loan not paid back");
        drip();
        expectedRevenue = sub(expectedRevenue, wad);
        // decrease seniorBalance by wad.
        // maybe call assessor.rebalance or smth, idk.
    }

    // update revenue/losses of loans financed by the clerk
    function drip() public {
        uint tinlakeInterest;
        uint makerInterest;
        expectedRevenue = mul(expectedRevenue, sub(tinlakeInterest, makerInterest));
    }

    // remove drop from mkr system
    function exit(uint drop) public auth {
        require(expectedRevenue == 0);
        mgr.exit(drop);
        // remove x from calculation of dropPrice so that price remains constant.
        // (price adjustment happens in `balance`).
        // basically the inverse of join...
    }
    
}
